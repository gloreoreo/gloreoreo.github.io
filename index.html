<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Passphrase"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = false,
        staticryptConfig = {"encryptedMsg":"c7ce30b41f456832cfc6e80198c3a637977d8774d9218b82acaa6fcffee5ccdb47609fb3c53b17afaf77eb93e1f5680789a578670f638957b28ab141b96085f0220c45059275cc401e19a2fc81a4a31f52d00d33d15538a8366a2c013254c931c66e354b671c817820928b06a76d38c5c782d8a874a8ef9e148880bc9f577dce065ac3bf347e9017299a4ed8f2036e14b4cd7cabd593804f8a56d8799c90ad79650e6465c3054538455c4608c2d74a6baad77fd4a7044d3633f53843015084ff261e07af6ae05a1c119a3e0c0739afb521ab3abd3ff066426e2d7bbe412ac111641a85544acdfdcc1cf7b86d5679681024c49cbb18507e6c706681c1b72dcba8822c7f4811f242f54f950fa329945df64d8b69e42b16a38673ac4263cedce53ff3fca958b2ac9ffce567b77b8b0d22ecbf22870d8dddb492490515f1e83c805e6e4d228d635b319105cb2af79b60875e7f00685f6ae95a702a952adda88c10fc876e132ddd537b6187eed39860161345cebed3ccdee1af0134ffc286a472c7a3c6c8ae94cfe419fc69d0a5f41fccf3e9bc113b5f09f640364ccc7f5a6dab200d024ef05f401f4433b68cd248f9d4c722da06b96d12a67c52c91fd5b227258da7b592c9dde014869294e26e0e5794bc7b02d854e10eacde569112d2a971dc85812dc4723b7dbbe34cca5942c4a3a4099ca6c7c30e5cee28de5fcfdeeab15fab1db7b3238a7d07184cdfda26b9759810e94ef45399c88db54cc43632f08d4c3198210852d9a40113ce2ca68641791552f00193e95781cb12c1c0fd0955ab90c10fa641946605e335127b96796c4dc5b1f6c47f89889083a1a8a82085e7be8eff3baa0fe08ba90dd2a442852c4295ca5d9cd8a87fd90b114e888b5dc2624b9a8a08f55ca0f7457904ead36541d18149d20589ce876a29e1f9fa3f486b1a0a9eef7a2803a3ecb2bbfa6283cb462e093b416d502d96e3d9bc2950dcec1992f0071c2e70631b7318ac0bc11bff3747f4aa63f4fc327ea8d8a2636a6880e9734793ac9601e7e239111bce1ecd5ae7981c08ea0a81ce5d6218e02bddd9c67d29cd7d8f1b98da363c5f287073fffb6f105b73b30902f04b3d31f9c097ca7398f1eeb4526debff8ede9b7f4f4515639af0c6f57bdffb992a6ee53a9a024e1a45164a9d7e922278c3cd2cb1501edf8081b9297f722c0a270781c37e1fade8fae019c7b67cd292b51d6de9a67a82ba58d171a677d43d15784a2d6f0b156e30fd48d192f27c1a624696f51f21d9be78b47530d4abc3a2783bcdf5f976dfc3bc0a072c7e1dfe63aa4f28b9b2d8e547c3b066c8a321177ad119eda287557e1fec6461d71c9e197bd6bb97dff5b91e0af9ac444eac1b55ef3f9666e028e1f010986253f3df4fba1bfa8725484b9e5a713f14c540dee6487375b02711386392e95b7e00c7ac36aa3accc22b28717476b0b17eed8b2a9d83c7877eddc832e0af10ea81b644771bc5117c29b351de70f4ad77644a0c60184d53643f6f004f28f6b60343117079581b081bfe974c2d1992f951f7e4230a891e08566f6a64dd733c564ff94e595e30ce3376c4a4d19631b577198cf60df309d3e63cdd7ebef153cfefc2377bb09e52b9a0f1e8775bbbb5460f6e9e6cff4c1b89d4b29a051c8ca4f1ca13822fd538628dffaf4c53fdbc0a0a530bd44ddb26b7bcf74773e30a4f2d101bf352c2b9e5b2e93d9885e6a18f2c534f9ccb762483f057d1e266f37afbb0612e807a21e3db3656f0900eb25d0fe015458f4b4aa600511266881019297614a473866cee39ee49715b55ed3f43e1ddcf795cd0e9bf7e789d8593ebf72399de1dd6105a25ed946eb5372896a8e46d5ac4da12497c4cab115addcafd37f27d56af9d56bd53538063d2fef724ceb2013df2cd20ec4dff0756c5ce06df0949ea17060b7f605bbc285b9f4f0fe2b347438b28a0930550acf52f82d90f726025881d7c4dcaa03cb325069fa57082c7c5bb2b82f4d870ce780de6a289df5e390f58af0e3144e5c1260de023bc3ce46ff4ddaed5f3ecbddf9be9f9c7123041bcea75d54c7c8fc2d0d6798609e21f21fc1987d5ef6fea59707967d7af3cc296a95844324e0178af67f09bd4c7e3b491d153d2e7286aa7f30238ad1d83e4142fc80d2579e33382f6afa26fcefd961928f7c18e07be3414d5fc8280e2d77e82f658912798d51a49fc738f17ae46a16d0ccfe4d4056e8ecc198fde763d3c3b166048bedea680cc24e56c59d32fe21ecec216523294c459724fe15867d3cac094cf838363d7de10b3d449d25ad90d84a551ab147d13e3531d5ce7f5941926bafe7a57a73e6420c2b901162fd15bf77e7970d8e6f8f855b19c4875d96ee4325d998b1bd3dbcd07590cabcca907c7a602fcf213ca619ae4ae02d9e13543fb0f8b5e92d52ed94541a1f7b457fb2b520801b8f94b64638feb2d66995f5be0ff72e95f9193c58ad0e622a12b6a7eb4388e6d3162911e8d74d471fc5d69ada77d8b2e60449d843a836f907f7ee6af031b11cafca2df4affbbd0e582e4869bc9e604077c097b8d65b3e6bca71c6051507c4f1a20288df9db1739de0d6b5f623860c5be9b8703fc44e63185aa8a4f51957c42ab6e33039798bf38c9f062097bc14a484d45e80f8b3adfb9c7eb4f77c0410162283a69e6f1078270a108a7acf25f8e9d938c9fbb18d880d1e0f799ae3793b0e36d5826c48265374b75a6ac1d7b92bb475184d9a7a26cd0015dd4537b9050f799681044555e2ec222bdb73cc8f4340159b1c0f4064f9e9c5e4621dec83b2ddafd6804669b2c4fc7ace3753f156af1b8c1a0e8fca17a1fb7fd1b5a89d1634955fd9447d800769dba12f701a4631a5280a401ba663f45bc398082b7e2d3da05f4ba901020439b4097d326e2a3f1ba5a04eabfc98503da3a4c53da6934ef3eaa93460a42886e962cf8396d6aa1f17bce0e90716b97b2f412300d32008489fc9c46495cc7762e0f000cd394e918948d2bab18775612b2f401f8762c8cf6da8ba3527f7b9f5de35277e2a638422b8a01f97cb1bf5ac2513300d00bf946fb0c821d82db7ea51b033744ee0961e1677d5df604758809a40103fdb6364bb6122767ba683ccb8635e5f31376237187bed67fc486514d6cc4f6b1e570c46f310cbb29f8bfc7679781e2f8415816833240642c2a98e9d6368ad63175d77eddf6ce24e5dfad42fde8c651ddc858940102897570aa31f4d75fc740bb833743c80f580e79c233ef190946212547c33a0dd576d94a96946b61e75a264a3c45056fc70d1e0df81efc730ea40fee5860b9d78140932f45bbaf8a0fc73494716ad9470cfad093c72f10bdc18541ab05fdd3242eddd954fbd3c6ad9d2ab6a2f51eca9067dd0249e23386be55554d66c6f2384f310a002c00254a59681c2e33e38288593510971a436f748139922a662ecab276af29b13854dda2b39ef42c7bb238fab69bd87e608330d5072fa300b910346ba8a8481f948b69907bb906a5369502228cbff44a496a211d779447dc6d51d648d50af092a7a25733dd4b53ecb9485a6d074c616a9917c02c16a2c378fac60a2c02c88956d9b35405055c73235213342c56f26f06f83133be5ea44056c05814af2f34ebafa3490fbb9821414da5c60b7fd57207cd9f8ba61d1a7cabc7a6228e8173c79300fb63706d15c8995853a35b1a70b608bd7a1289904ae8734f901cfa59ca2b2b49fcb1153ae0008a289c1f51ea30d7eaccc72c48c3a5284d899cfeab8eb4d05940d2cf4b851c2ced53763580ea5f51f7bfcc6d9aa2d30d8c5086d4285139263211eb3e40b554e271c919ae0ba2487d43e2de6d815aa61a66610a80dfa9b66fba78c367e3ef874505f452b2106d736871659c4bcb821125cd7d486b4d586ca1fe6a90e8ef3ae6c0ae14d03bda2473f4ac8e1324ee65152af887d003246c8793ae9daf60adaf36527b83a25dd966dc81014a800a9c1018f921b6f829b39ab14afd9574249694f9753e89fa435ae3cab3fd4333d08b1b66a0064201829c105dfd68da50a76e5862ba8716292bc6bf6835ea99b8975c6a95b9d00b04c17e0600b3529ec8c380679c1c9456e635d2cb44606327e9430b4419b41b66f5befcbf6554be9bc95d1f92d803724e16845d805296bb48b98bcc3488850db1385bb4ee79f776d184cea96f216e3cc407d8d80975d0f59016245ada4986804103b0021397c1992bd848093cfd43e3946c42c8f1141be089f91d2f582beb4cf0c98e181054e2d46395d37f34c57dc693b56aa45297566abcec4b40e62dc02ba1831a7d8e2be2b454fd74261f4b5142ef704d81168494989a3f12cad40cf4d8b5c99c8c7cd57471c6fa686881fe0af4808db30c5833efdb6512211b04aaebea1ee62880d231e0ba3dbb854231787ba8fb8a6e22cfd40653cbea77f8d084c572ee8cca5745a5c109b333339b2334b0dcbb7e42d1706e14e625a5704d0dd491099f6655103cb1606442b3ca18afeeef9dccd8a9729daeb06dc3f9cd032612e60aa005787437eebe32467e50d93aee04d3767a9ba2e5897b28bfa7a75c8259f1a3f0b9e508a0ba9980c522156b7cd67da00c1c866f9682fe2ea952de913d6dfe207cb6f6e01e8aaa2881e54012576cb2c0c03d51830ec2f7d7a20495f21a4afce2773015d1fb21bd016a5005f79ba770fc2cc831df346b1051267f9adaa62822250df9f9b8dd6e468957159a11a1c866f0db611bd6cff5ae814ab6b7d341be5025ebfe20bd4ec023d44e160853315ab4b59a7d713540d11b245e2a58851ad0cdd6219092f1fe68ac9e8459d251e341af2643fa375fdb3501736948498dd368ac20418a0ddb7fce1edd5c3bcf135bf6b83b5bc924dcd30ff88d180f23594d1b327825e6d6f86949258f08c64638b3981402e7380b859b2fcaea99df252af11c01ac1002abcbbd91fbfcf5211c235d855435cda00d4c127f9f8cd660218eacab1bc2f7bd5fe121c7dffd603414626ea209a7eef3193fece408626f5d1a49596fc7e26df87ec101a80bf3d170772513ac4b0728831c562ae274edf4b5f926aac3d20bb158966850d6bd941f619c1d3085abb9e9aeb7bebe0db3cc69975ad7db2fab4ffcf4140f9037386a3735e0c4957d639ab27525a0ac4fc0473af6037e58ad1bda5c5e6c5a581851c854ef47d40efe61a92fb3c0d753db561e418aac2517ebe4394510ebbb057ed75f2334ccfbe696a9919bd12231b20cb2cf40528138b80bc6e32e98861d5084badb1b5349e6c4eb0e27fc1feb27419439d8754613a6d8bd10965d08c212d79b685c770e8d8ab5713ffdeb41d09d9a13c31612c27478a83fdbabc185f442e7ebaa87251f6efed201cd75f52c60754c9f9b7185c8c1b3477750ed1f93c0edbbaee23499b36a5d9855b0a1845a588131fc924cfa6516e939433072a3cbc956e7d1588c35ba3b732d811df365f6f7703bb32f7c121bbd87ed6afc7dbebb5268706182bc6404425621cdab7a9819ed3b80fa4eb1b7a202a3d08bdbca6266060fdd17a2c68ff53de57506dcda666190dc86153407263dba2155585228351d62fd0337f34c8774994b26c9e53a0a9cd2c1df3cf4db2966f48dcf02fd2b9393ea3b3a05127236b8ea39ec3054f014898be448dacd35b0b53eceb9ee7f80c39c2f6d78297f88698d66370106b11972390490a38cd0e8d19445e62732ea1536134ef5ea55a0529ebb4809fc8495b66b0999053476d877a1b2548fa20211c9214fac1f244d93669cbeb52b3589e8a193e6f474f7aa6d7817c644bc0f7cef197cb4c32b1bfb3b614429bac845bec323c4a7ded3837a0910b57a758fd29504c83f1aee8b8266c87cc474edf8f11eb262cc979bc5ebd01d0a43578607d2be54396bd8f29659d3e5c69d9061a34c89371538740e8bc584c34c7bafa406beb31d51be12156aca0680112c7cb73df9a156354e4fdb8e292e0841b7cd25836b0dc797979e04369de893492c397154fbc706be4353c66e4df631c015ced8c3913484f4e18e1ce97401c7fad49ef95f895fa78068c8f95784d4126d23f3c4be3e91803f77e21f8d80a28b07d4016f599a152b9228f4a67934eb4e71533c0db47cab2353274c3397077cb490f4215f02f09c1bbcf744f06dfd72a30ed355e057956eee767695ac8dd0e1a91fdf54ba8f71574fb00fa290a02da582ffab81c0de9baf668be5cb7243f55c8b0fb3ad4945e5d7d17df52490ef319c041f7ce26f8c4dd3169f3ae3c147bb4c9e51e13968356200e5ef2df46b2c77d0a13e23722e6f75a729b71b16a3e6e45491fa8e080cdada8e57c32ce8a91b73dcd2222e21df4952b04c7832b381ef9deaa02c85d0317a6d2678cfb7d39e1fc6dcc08ca3252a25a2c3593d0404857715173630ea050a9556088a1307177d71b4de6546dce7fe34fd8e3dd8808beaa89716a342221dda2ee803df307658f55340515f04ffe1e7353a44e06bc81b88931a9ce42a8eb4bbe440aa60c9e76576bda9ed0ed79644b461cd57e59d85fac7f3f8f372a37c0a37502d0ba52d469892c32ba9c97144c715ff4edbe7246b3c11969bb01d6280538c82e2a66aa955757b4619588efe69a328353ee1cbff232a33c3d3cc97f22b39f20c849c12bd6b29fb1075a7c89c0e7ad02bed407aa97f9523a1b1ae1fd5b6e946e214a07d17917e1eee2e44389d8a6a097b5d16be9af4fd5d2a762e689797c342fa04297434de55b8b9b4217a792fbc9c2a6ea113a7d4decaee6fe751bb60b1245f06080482b05852566c4ff9498cca21c359d0edb26d4621dd134cf9915f4bd8a928da33999d207c05df5f4b3ef48aa1110b314063d85b2a763dad63ef8a8b7d3a483fbd5288ea37e04829d40379cdd2500713f8b34dae586cd8eeccd79c80de290b06668ab23199f9090d9941b4acce43fc13c9df83c640c378652922bce7d8568235f44d6882e11f72c7329603d63cbccdf9194863383d1e265629c25ec336a100b2ff19631c08cf6b5c1dd971de995bc1066c0c895d956130f2c245bcc809613b684fbff20a87551d9ed664c68ab95e9b6754a6d548adcdae86d3669d2a0d6a823543b782b52395445b611248c9675d4ccfe2389d5fb682be2a710141d6003644e7634e4282b5574f694e2de0ee27ab2b0b071b2fa11737acbf7a1e01db081d96300051e451eeab53ce7440a04f2a2a340d3bacea33af69124d31aa80780b292d1dbd07943c7b9aab6fd795faa10608ed5ff766d2d209d2b79004998c17c4e7b5a51c49cc467eae36a4b46b5edd48301d7763a33afba218557cc485adbb82bcfc4a7fb70fe0fc6a331fc355eed305e2ac024211110e47cfdf006b5d1f133af0bf42b32ddcbc0ef7677ee047e887fd1cdc5895bc5dbc2dd627fbf7d73f9fccc5f8c3c30e2b534f9648188389028f40f27917112d5b207a86f740a25679526e2f8e6ab2b7a53ddc18b9dc455053609670fbb527d730547e1d0de1ee736eef112173a0e8ff67d3ad718a4b0914685569c3fc5c49e4cb446fd8a618ecdcbe3266f9d774712eb87b9aa2fcf8a8d6df9e2a78df451cf938ac0cdd438ccf3c907e314e7b5c7f53f6a60b6f151db0832ac75ed6c7f5ab85e6a2f65efed7247355388d3dc4d038a77681459886a716f33bb8502191c7455ac465d07f149f15823afc489d34a3270b102e7935629a29f6c797ba47797a220a63fc3eefcfe60f58bbc42b32497e7e513185932530a7a5a43ecfb1f4934d27e2bc76f44e4e93774ebc0f218b0245d3337111a74e62fab329f346ac955e6e19c0029c7aa730ae13be28dd6ef544613dd99324c72cdf3854a5bffe977de0c948d0909fdd23e738c88fcd8b696936642eddf5c6f72203fef2c21308c9e4ba1bfae03136ce5ddb905c0e8d3ad063a78d392434de09908633b8ff89102c46925ac3f37fbf8b1d85b7ad384b1e490066cd7228efccfc19db28b65b9bc32fcb5b1215a4a741aa05ee8b0f9e7162ce43c41084bc01d5c2c3301ae9f6dc7406879c32ef513166e862f445a6221a582d6a659c339bcfeccb8eff245f53c4b0420176ef5fddc2bb1b4a2647be53c000601c15e4b9dac463eff41c7b7b6df25613b79a4f052ed398afc3ee73a3f2916c24980bd7363c86fc9627fe13b2950a3c29f78d49c30953dcfcc4ef241c64da9e168f436071b0b4791846c5522f6b759b15f5c7e5283bee37f58337d8a6ea0df57e3fe729de9a83beeadd059832400bc7a7f96af76cb2d03dbaae7bc9c8a1a5a739af966dfd4f0375241beca9d67ba95419a6b524815b9f8cc98e9079b2f3dd05c923ce17b924e34c90256f74a6e6f00d7ab64bb4bd250deec4edba0edb4a6bb4fff97acf977613b40aba6e47aa32bad92902683b765cf076ad1284a6e33c57e36d39b3a1282ef709112f3e2989f8966b9cb85b478dfc7fd54eeb35d26e0239097fe98ac1c5ec5388ec07231926040ab4d1d89f0a91100b786f301f68940f182ad480a0cb537585b571d38a364de137234ae4a34b2b026d510f771fce243c774e8b134e57363904889b36836ba7ba7815697df97079046ae761cea8f0f5d8fe724168fcad3ad45990c8b6073a3a5f2a8407d13e3ec5b7891278a4fb2b1a54becfc4278dd0705c9526d345220113b20499df5f23d74edf2d05b64cd4c6c9217606045685bb9e821fb1616dddb2a40e28dc88c49a5f11e4043c8453aeda260aee5f21472a3a11b7b1fd3ad5c23c6d25baa2eb1875e110596b4090220ebc20b0f36288683f9d968edc0108bed09c274934fad6ff8d02f158f0a63a04625fa6f49b587ca5652d333a94c24ce1684de81637149ff31281da83770eb0c7225b15d3bcc3410d7099fe1a97585cdf17076da771ea38dda65607cd57b627139f26c201f7180011a5681c972c801a99f4dc6c95d1ec3cec231cc3b2184a228af4066ca7ad5fed2637301f760df7cf255993dc741e271fb5dcfc55e1454ee171ec2e43dc25c5d944f0ed2650118897a0b201517db84349e87cfcfad9e5ef5fb19852caab3ef5a857ec0a1e17045623b3fabe3f5fabed8834da29c2076feb59310b67e6643ece66e0ab0555e8096910993855e32545779faebcb7fa6ef026944c92ad8dfca02fde2e9168717df1c0c16e724e1c3e8c4f8d1d24df7544e5f4e01154d082b49dc7f679060f4e927d061d46a70a5e6c761ece5f3dd2e41794ce0baaf1872c440b85386e787f644725241a91b408f49c43249704b57e172a889717afceba21bdb7ec50876f80543049fe9abd2a112ae646f61e144eececd857f304dcf732aef470b3775b066f79d903a582d8e0ef87e3edeaec4d4d5b63376d019cbe0b8cab93a397b72620e760122f8a212559ee40eace222a43e8133912a5da22157f9a8d94dcafaaf3e237af69f047b750767cba32dc0b8c9c4754acd7b9a2a497cc893094e5c071f1ee4dca7fdae8b4552fbce026272d2f5a6561224bbc0cfcdb5f9e4489357dec82cd878980e00ed12bf38aa0425e45900ea93ad054e6a4d9b750c34d3b944ee773f2eb959885479a7df2e327308a94a83f30c80754c89d36f5d9d3c4c4c93f10f5589c98ee48555c4329cacf09d86795708f6861d465ebf490968f3431d9bcb50783959942b9f56715a8bb0147b878c4ffd1eb11d23992bc5e7c88da05a21c89550211461214395ac16babf1f41db500247acfe6ef614039ca9f6be6e1b9f6ded938ced9dbf2fb6b195b469cb96aec1f31396543d61bb9b4ecc21a0222193cea1ae929accf28b0e03809dc671741c1c7dce4eb30b7748f26af138f4d2a52ef3bc62b7ffd482fd1191cc5d44c25d7a6fe6df82d2d3cb3d5692db5ac80e8328e23def051339d6ac91b6ea39179f17957145ab854689d44356b7b29b7a9d0ec0049ea47c33b8a396355484933cb82d1220c8b7ac818c6879fca13bce3ecc182631a90038bf4192b4248680f08f48e3632246e72856d9dfe6362671db4a697867c8355bd73f06a079332bcf437f390b2228abcfabb512fafeb5fc2b5982390552126a20f0dd9018c28996d43a3cb71d2dcc0f2bd1ba9032005f646b1f1d3420cd72f9e74eae7f762cb9396b8d395a126c487f17b26513e69e49e08332b741b8e2975af95261e446a0b733864a7517392338edb6aae25eb3fe3794729b5de2064623dcfdb4c28fe3f90de03c1275f68fd4444c6251f80e83ad24c0a1f56b46bf8b7ec283309cc00514a2c150397b9e69154438cd33ccf8d8e986969aa6b154a280d1ed26be4c4a749f9a6250e1cccbd083808c6789a02f89b499cbe3510b9faff033291f62236c3bfbacfa0265c105afe1830303521b61516c982e80acebacf5917934782b0355a996093431c810904c02957bc73d987091a104a4b0193e85f6ba6048d35041cf9f07f4daeaf35a2c7a2ff160007fe217263db9dac497ba1a6895c9b92d1fa0e2b986696d12bccc82ed256d5a1dcfdf7e471fff2dd28cea75be16396bda4d2228efb9ed857f4fe3b945090899601e07e6a0f1e77a42c38f2335c25ea27d41d0beb784bf5e3567a44547dbcdbd314cfe738981870da4060190df4bd05641de3a9a15e10a5a37805ea9c53ca1db7bdc06bbb7a7a9aa1b2b98c3fbd49f2bc86b464800147e33273997fef4c8228c71e443f274f4ad726462164e0f2cb7bf3090076ff1f4b2e76e40fba27ce811b14e69e966a0bfa56aafde7b7ac4c0d5401ddabe4f9cc620f93988465992ea908f56c77c21c9597721726ef11c934caf6c2e835a24cc8c1b179969b0f092080352dac891d4b379ec0abd428bdcb52a0e338fd3c4c9f978018a79f46fd07cf2d870c8551100a10a3950fc55fe86353b5871f139409c3c789c34f23c4ec193e4a664e80f090acacfdaa5583d87e762427f066154718e09e70e434178a287bb10c83a556e164bad619929886926f30ceff140f8698cc44c7e429df263529d6d93caaaeed510cbda3c5cda6583758fa21e2e532eeb5d99a561e960b942ebcdc80ed9c3589c9b6d79021d9cf12124651107c1a5d03b93ff72653d9d5f30c07ea104387783a666d81fd3e463862a3d5fcb6980a5c37db13c8ef03c550218c2460c242ac282fb201c0e81e31dea03d3238d437567d996d553f9e30b1c1c8db7c2292d9d8f69de5315d3661f7a2fba93948851347a275203b233d73f9df695170cab60e92198496dd0545450f6bbfd19b018c4b1b15cad74d402e772b41a5e2d7aaf14a2e2366aead2374043f0cc66bf819c27b7d106881b6422649ffa3e9e2a1cbe812bfcd4018d154aa56c1cbf3547b3a91cabd3af1e3a3307822252d6ca6e3afa05e0cb0f7d617727e525248e65f5632d96d6db9d5c87af1bcfd12772568d45fd3411480d6896eae28663c22652c46974c2cb8fd7b221552e3af9025c4e19d926ab61365a03c2fcb6f045da4e70be132b724861704bcbe099d8e18b3dc8fb4aa511d8327d74c121e50a28d4dc266575659d4d26d36e34f0a056809d0fa6ec429f01ce17e76de6b3f108812085febde9e35c27db3f2e2a2c1fcd015cac59f9b851711a86488db85074e33acc4ef79a7ba7e1141d10b871026d484706040e41069dfe83841b624","isRememberEnabled":false,"rememberDurationInDays":0,"salt":"9dc4b542f43fc127af3d2cd9a9b79f3b"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
